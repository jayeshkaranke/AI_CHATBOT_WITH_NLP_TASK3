# AI_CHATBOT_WITH_NLP_TASK3
COMPANY : CODTECH IT SOLUTONS
NAME : JAYESH KARANKE
INTERN ID : CT04DF2754
DOMIAN : PYTHON PROGRAMMING
DURATION : 4 WEEKS
MENTOR : NEELA SANTOSH KUMAR
DESCRIPTION OF TASK3 : Internship Task 3 involved the development of a fully functional smart chatbot using a graphical user interface (GUI) implemented in Python via the Tkinter library and integrated with OpenAI’s GPT API. The primary goal of this task was to create a desktop-based interactive chatbot capable of generating intelligent responses to user inputs in real time, mimicking natural human-like conversation using the GPT-3.5-turbo language model. The script began by importing necessary libraries such as tkinter for GUI elements, scrolledtext for the message window, and openai for interfacing with the language model. To ensure the code ran smoothly, it was necessary to install the openai Python library using the command pip install openai, and although tkinter is usually included with standard Python distributions, it may be installed on Linux systems using a package manager like sudo apt-get install python3-tk. A valid OpenAI API key was required to authenticate requests and retrieve responses from the GPT model. The application defined a core function named get_gpt_response(prompt) which accepted a user’s input prompt and returned a coherent, contextually appropriate reply generated by GPT. This was accomplished by formatting the conversation into a message structure expected by the openai.chat.completions.create() API endpoint. Another function send_message() managed user interaction, fetching the typed message, displaying it on the chat window, requesting a reply from GPT, and appending the response back into the conversation window. The user interface was built using Tkinter, including a window titled “CodTech Smart Chatbot (GUI)”, a scrollable chat display area where both user and bot messages appeared, a text input entry field for the user to type messages, and a "Send" button to trigger the chat response. The chat messages were color-coded using tag_config, making user messages appear in blue and bot replies in green, which improved readability and interface friendliness. The GUI loop was maintained using root.mainloop() to ensure continuous application responsiveness. The chatbot could handle any form of user input, from casual greetings to career advice, as demonstrated in the sample output, such as guiding a student on what to do after completing 12th grade. The flexibility of the GPT model enabled the chatbot to provide intelligent, structured, and helpful advice on a wide range of topics. This task showcased the integration of AI into desktop applications, giving users the power of language models in an easy-to-use interface. The architecture could be scaled further by adding new features like saving chat history, adding voice input/output, or supporting multiple GPT versions. It emphasized real-time user interaction, asynchronous API communication, and GUI-based application development. This task not only helped strengthen Python coding skills but also introduced students to API authentication, error handling, and dynamic UI behavior. One major learning aspect was handling exceptions and fallback messages in case the API failed, ensuring the application did not crash and instead displayed meaningful errors. In addition, managing layout with padding and widget alignment taught practical GUI layout design. By linking natural language understanding with graphical interactivity, Task 3 bridged the gap between backend AI logic and frontend user experience. It reflected real-world use cases like customer support bots, educational assistants, and productivity tools. From a developer's point of view, it promoted the creation of modular, maintainable, and scalable Python applications. Repeating the structure, logic, and UI design across domains such as healthcare, education, e-commerce, and banking could lead to robust domain-specific assistants. The combination of API-driven responses and real-time interaction made it a practical and future-ready project. It also encouraged best practices like code readability, separating logic from UI, and using descriptive function names. The chatbot could easily be extended to include command history, voice input via speech_recognition, or text-to-speech via pyttsx3, which can be installed using pip install speechrecognition pyttsx3. The use of OpenAI’s modern models made it possible to integrate state-of-the-art natural language processing into a beginner-friendly application. This hands-on exercise also helped understand rate limits, latency, and token management when working with public AI APIs. Overall, Task 3 was not just a technical implementation, but also a creative project blending software engineering with artificial intelligence. It helped enhance skills in GUI creation, API integration, and building smart tools. The chatbot provided instant feedback, which was encouraging for users and beneficial for testing model responses in varied scenarios. As users typed prompts, the bot would respond almost instantly, maintaining a conversational flow. This offered a glimpse into how intelligent systems can assist users in daily tasks, learning, and decision-making. The final output, as seen in the screenshot TASK3_OUTPUT.jpg, demonstrated a professional and usable desktop chatbot that could rival web-based assistants. With this foundation, developers could further deploy this tool in packaged desktop applications using platforms like PyInstaller (pip install pyinstaller) to convert the Python script into a standalone executable for Windows or Linux. From simple greetings like “Hi” to complex queries like “What should I do after 12th?”, the chatbot provided relevant, well-structured answers. Task 3 represented a milestone in creating real-time, AI-integrated, user-friendly applications and will serve as a base for future projects in conversational AI and smart virtual assistants.
OUTPUT : ![Image](https://github.com/user-attachments/assets/90a6bf73-e4d7-4bad-82ae-046384a0ac25)
